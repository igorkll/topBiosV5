local a,b,c,d,e,component,error,xpcall,assert,f,checkArg,pairs,type,g,h=table.unpack,computer.pullSignal,table.insert,string.sub,table.concat,component,error,xpcall,assert,computer.shutdown,checkArg,pairs,type,table.unpack,debug.traceback;local function i(j)return tonumber(computer.getDeviceInfo()[j].width)or false end;local function k(l)local m=0;local n=nil;local o=false;while true do o=false;for j,p in component.list(l)do if l==p then local q=i(j)if not q then n=j elseif q>m then m=q;n=j;o=true;break end end end;if not o then return component.proxy(n or"")end end end;local r=k("eeprom")local s=r.address;local t=k("internet")local u=k("beep")local v=component.invoke;computer.setArchitecture=nil;local w={makeReadonly=false,get="",set={nil,"storage is readonly"},setData={nil,"storage is readonly"},getData="",getChecksum="",setLabel={nil,"storage is readonly"},getLabel=""}local function x(j,y,...)checkArg(1,j,"string")checkArg(2,y,"string")if j==r.address then for z,A in pairs(w)do if z==y then local B=type(A)if B=="table"then return g(A)elseif B=="function"then return A(...)else return A end end end;return v(j,y,...)else return v(j,y,...)end end;local function C()component.invoke=x end;local function D()component.invoke=v end;C()local E,F,G=false,nil,{}computer.pullSignal=function(H)local I={b(H)}if not E and I[1]=="component_removed"and I[2]==s and I[3]=="eeprom"then f()end;return a(I)end;local function J(H)local K=computer.uptime()while computer.uptime()-K<H do computer.pullSignal(0)end end;local function L(M,N,O,P)if u and not P then u.beep({[M]=N})if O then J(N)end else computer.beep(M,N)end end;local Q;local function R(S)if E or not Q then return false end;if S==0 then L(1600,0.05,true,true)L(1400,0.05,true,true)L(1400,0.05,true,true)L(1600,0.05,false,true)elseif S==1 then L(1000,0.2,false,true)elseif S==2 then L(1333,0.05,true,true)L(1333,0.05,false,true)elseif S==3 then L(2000,0.01,false)end;return true end;local function T(U,V)local W,X={},1;local Y=1;while true do if Y>#U then break end;local Z=d(U,Y,#V+Y-1)if not W[X]then W[X]=""end;if Z==V then X=X+1;Y=Y+#V else W[X]=W[X]..d(U,Y,Y)Y=Y+1 end end;if d(U,#U-(#V-1),#U)==V then c(W,"")end;return W end;local function _()F("writing to eeprom")R(2)end;local function a0()return v(s,"getData")end;local function a1(a2)v(s,"setData",a2)end;local function a3(a4)return T(a0(),"\n")[a4]or""end;local function a5(a4,a6,a7,a8)if a3(a4)==a6 then return end;if not E and not a7 then _()end;if not E and a7 and not a8 then R(2)end;if a6:find("\n")then error("\\n char")end;local W=T(a0(),"\n")for Y=a4,1,-1 do if not W[Y]then W[Y]=""end end;W[a4]=a6;a1(e(W,"\n"))end;Q=a3(11)~="0"local a9=k("gpu")local aa;local ab;local ac,ad,ae;local function af()a9={}setmetatable(a9,{__index=function()error("gpu and screen required")end})end;if not a9 then af()else if not component.proxy(a3(10))then local aa=k("screen")if aa then a5(10,aa.address,true)end end;aa=a3(10)local ag=component.proxy(aa)if ag then a9.bind(aa)ac,ad=a9.getResolution()ae=a9.getDepth()ab=v(aa,"getKeyboards")[1]if ag.setPrecise then pcall(ag.setPrecise,false)end else aa=nil;af()end end;local ah;if aa then ah=a9.address end;local function ai()return ae~=1 end;local function aj(ak,al,am)if not al then al=ak end;if ae~=1 then if ae==4 then return al else return ak end else return am and 0xFFFFFF or 0 end end;local function an()a9.setForeground(a9.setBackground(a9.getForeground()))end;local function ao()a9.fill(1,1,ac,ad," ")end;local function ap(aq,ar)a9.setBackground(aq or 0xFFFFFF)a9.setForeground(ar or 0)end;local function as(aq,ar)ap(aq,ar)ao()end;local function at(au,av)local aw=math.ceil(ac/2-unicode.len(au)/2)a9.set(aw,av,au)return aw,aw+unicode.len(au)-1 end;local function ax(ay,az,S)local aA=S or 1;local av=ad//2-#az//2-1;if av<0 then av=0 end;while true do as()local aB=aA//ad*ad;local aC=av;if aB==0 then if not ai()then an()end;at(ay,1+aC)if not ai()then an()end else aC=0 end;ap(nil,aj(0x888888,0xAAAAAA,false))for Y=1,#az do local aD=Y+1+aC-aB;if aD>=1 and aD<=ad then if ab and aA==Y then an()end;at(az[Y],aD)if ab and aA==Y then an()end end end::aE::local aF=false;local aG,aH,aw,aI,aJ=computer.pullSignal()if aG=="key_down"and aH==ab then if aI==200 and aA>1 then aA=aA-1;aF=true end;if aI==208 and aA<#az then aA=aA+1;aF=true end;if aI==28 then R(3)return aA end elseif aG=="touch"and aH==aa and aJ==0 then aI=aI+aB-aC;aI=aI-1;if aI>=1 and aI<=#az then local au=az[aI]local aK,aL=math.ceil(ac/2-unicode.len(au)/2)aL=aK+unicode.len(au)-1;if aw>=aK and aw<=aL then R(3)return aI end end elseif aG=="scroll"and aH==aa then if aJ==1 and aA>1 then aA=aA-1;aF=true end;if aJ==-1 and aA<#az then aA=aA+1;aF=true end end;if not aF then goto aE else R(3)end end end;local function aM(ay,az,aN,aO,S,aP)az[#az+1]="back"local S=S or 1;while true do local aQ=ay;if type(ay)=="function"then aQ=ay()end;S=ax(aQ,az,S)if S==#az then return end;local aR={}if aO and aO[S]then aR=aO[S]end;aN[S](table.unpack(aR))end end;local function aS(ay,aT,aU)if aT then return ax(ay,{"no","yes"},aU and 2 or 1)==2 else return ax(ay,{"no","no","yes","no"},aU and 3 or 1)==3 end end;local function aV()local aW=computer.getDeviceInfo()computer.pullSignal(0.2)return aa and(ab or math.floor(aW[aa].width)~=1)end;local aV=aV()local function aX(av,aY)local U="press enter or touch to continue"if aY then at(U,av)else a9.set(1,av,U)end;while true do local aG,aH,aZ,aI=computer.pullSignal()if aG=="key_down"and aH==ab then if aI==28 then break end elseif aG=="touch"and aH==aa then break end end;R(3)end;function F(U,a_)if not aa then return end;as()at(U,ad//2)if a_ then J(a_)end end;F("bios loading")local function b0(U)if not aa then return end;if not aV then F(U,1)return end;as()at(U,ad//2)aX(ad//2+1,true)end;local function b1(au,b2)if not ab then b0("keyboard is not found")return""end;local b3=""local aY=ad//2;local function b4()as()local b3=b3;if b2 then b3=string.rep("*",unicode.len(b3))end;local b5=au..": "..b3 .."_"at(b5,aY)end;while true do b4()local aG,aH,Z,aI=computer.pullSignal()if aG=="key_down"and aH==ab then if aI==28 then R(3)return b3 elseif aI==14 then if unicode.len(b3)>0 then b3=unicode.sub(b3,1,unicode.len(b3)-1)R(3)b4()end elseif Z~=0 then b3=b3 ..unicode.char(Z)R(3)b4()end elseif aG=="clipboard"and aH==ab then b3=b3 ..Z;if unicode.sub(Z,unicode.len(Z),unicode.len(Z))=="\n"then R(3)return unicode.sub(b3,1,unicode.len(b3)-1)end elseif aG=="touch"and aH==aa then if#b3==0 then R(3)return""end end end end;local function b6()F("garbage collection")for Y=1,5 do computer.pullSignal(0.1)end end;local function b7(aH)if not aH then return nil end;return aH:sub(1,4)end;local function b8(b9,ba)local bb,bc=b9.open(ba)if not bb then return nil,bc end;local b3=""while true do local bd=b9.read(bb,math.huge)if not bd then break end;b3=b3 ..bd end;b9.close(bb)return b3 end;local function be(b9,ba,a2)local bb,bc=b9.open(ba,"w")if not bb then return nil,bc end;b9.write(bb,a2)b9.close(bb)return true end;local function bf(j)local bg=component.proxy(j)return bg.exists("/init.lua")or bg.exists("/OS.lua")end;local function bh(j)local bi={}local function bj(A)if A then c(bi,A)end end;bj(component.proxy(j).getLabel())bj(b7(j))return e(bi,":")end;local function bk(bi,A)for bl,bm in pairs(bi)do if bm==A then return true end end;return false end;local function bn(ay,aH,bo,bp,bq,br,bs)local a2={n={},a={}}local bt={}for j in component.list("filesystem")do if not bk(bs or{},j)then table.insert(bt,j)end end;table.sort(bt)for aZ,j in ipairs(bt)do if(not bp or bf(j))and(not br or not v(j,"isReadOnly"))then a2.n[#a2.n+1]=bh(j)a2.a[#a2.a+1]=j end end;if bo then a2.n[#a2.n+1]="clear"end;a2.n[#a2.n+1]="back"local S=1;if not bq then if type(aH)=="number"then S=aH elseif type(aH)=="string"then for Y=1,#a2.a do if a2.a[Y]==aH then S=Y;break end end end else S=#a2.n-1 end;local aA=ax(ay,a2.n,S)local j=a2.a[aA]if not j then if aA==#a2.n then return nil elseif aA==#a2.n-1 then return false end end;return j end;local function bu(b3,bv,bw,bx,by)if not bx then bx=0 end;if bw then D()else C()end;computer.getBootScreen=function()return aa end;computer.getBootGpu=function()if aa then return ah end;return nil end;F(bv)R(1)E=true;if bx==1 then local aI,bc=load(b3,"=boot")if not aI then b0(bc or"unkown")else if by then _ENV.biosApi=G;if bw then _ENV.biosApi.setDataPart=a5;_ENV.biosApi.getDataPart=a3 else _ENV.biosApi.setDataPart=nil;_ENV.biosApi.getDataPart=nil end else _ENV.biosApi=nil end;local bz,bc=pcall(aI)if not bz then b0(bc or"unkown")end end else assert(xpcall(assert(load(b3,"=boot")),h))end;E=false;C()if bx==0 then f()elseif bx==1 then return elseif bx==2 then f(true)end;error("return code is not found")end;local function bA(j)local b9,b3=component.proxy(j)if b9.exists("/init.lua")then computer.getBootAddress=function()return j end;computer.setBootAddress=function(j)pcall(a5,1,j)end;b3=b8(b9,"/init.lua")elseif b9.exists("/OS.lua")then w.getData=j;w.setData=function(j)pcall(a5,1,j)end;b3=b8(b9,"/OS.lua")else error("boot file not found")end;bu(b3,"booting to drive: "..b7(j).."...")end;local function bB()if aa then local bC=tonumber(a3(2))local bD=tonumber(a3(3))if bC and bD and pcall(a9.setResolution,bC,bD)then ac,ad=bC,bD else ac,ad=a9.maxResolution()a9.setResolution(ac,ad)end end end;bB()local function bE(bF)if not t then return nil,"internet card is not found"end;local bG,a2,bH,bI=t.request(bF),""if bG then while true do bH,bI=bG.read(mathHuge)if bH then a2=a2 ..bH else bG.close()if bI then return nil,bI else return a2 end end end else return nil,"unvalid address"end end;local function bJ(bK)if not t then if not bK then b0("internet card is not found")end;return true end end;local function bL(au)local a2=a3(8)if a2==""then return true end;local bM=b1("password"..(au and" to "..au or""),true)if bM==""then return nil end;return a2==bM end;local function bN(j)a5(10,j)as(0,0)aa=j;a9.bind(j)bB()as(0,0)ab=v(j,"getKeyboards")[1]ae=a9.getDepth()aV=aV()end;local function bO(...)local bP=""for Y,a2 in ipairs(T(...))do bP=a2 end;return bP end;local function bQ(bF)return T(T(bF,"//")[2],"/")[1]..":"..bO(bF,"/")end;local function bR(U)return bO(U,"/"):match("[^.%.]+")end;if a3(4)=="true"then w={}end;local function bS()local bq;while true do local j=bn("select",a3(1),true,true,bq)bq=nil;if j then a5(1,j)elseif j==false then a5(1,"")bq=true else return end end end;local function bT()local j=bn("fastboot",nil,nil,true)if j then bA(j)end end;local function bU(bV,bw)if bJ()then return end;local bF=bV;if not bF then bF=b1("url")if bF==""then return end end;local b3,bc=bE(bF)if not b3 then b0(bc or"unkown")return end;computer.getBootUrl=function()return bF end;bu(b3,"booting to url: "..bQ(bF).."...",bw,1,true)end;local bW="/topBios/utilities/"local function bX()if bJ()then return end;local S=1;while true do local b3,bc=bE("https://raw.githubusercontent.com/igorkll/webMarket/main/filelist.txt")if not b3 then b0(bc or"unkown")return end;local bY,bZ,b_,c0=T(b3,"\n"),{},{},{}for Y=1,#bY do local I=bY[Y]if I then local c1,y,c2=a(T(I,";"))if c1 and y then bZ[#bZ+1]=bR(y)b_[#b_+1]=c1;c0[#c0+1]=c2=="true"end end end;bZ[#bZ+1]="back"S=ax("web apps",bZ,S)local c1=b_[S]local y=bZ[S]if not c1 then return end;local c3;while true do c3=ax("select mode for utility "..y,{"run","download","back"},c3)if c3==1 then bU(c1,not c0[S])elseif c3==2 then local c4=bn("select filesystem for save utility "..y,nil,nil,nil,nil,true)if c4 then if aS("save utility "..y.." for drive "..bh(c4).."?")then local b3,bc=bE(c1)if not b3 then b0(bc or"unkown")return end;c4=component.proxy(c4)c4.makeDirectory(bW)local bz,bc=be(c4,bW..y,b3)if not bz then b0("error to write "..(bc or"unkown"))end end end else break end end end end;local function c5()local az={"80x25","50x16","25x8","64x32","40x20","32x16","20x10","clear","back"}local aA=1;while true do aA=ax("resolution",az,aA)if aA==8 then a5(2,"")a5(3,"")bB()elseif aA==9 then return else local c5=T(az[aA],"x")a5(2,tostring(c5[1]))a5(3,tostring(c5[2]))bB()end end end;local function c6(bK)if bJ(bK)then return end;F("downloading the update file")local bb,bc=bE("https://raw.githubusercontent.com/igorkll/topBiosV5/main/biosv7.bin")if not bb then if not bK then b0(bc or"unkown")end;return end;if bb~=v(s,"get")then if aS("update?")then _()v(s,"set",bb)f(true)end else if not bK then b0("update not found")end end end;local function c7()while true do local bz=bL("open password cfg")if bz==nil then return end;if bz then break end end;local aA=1;while true do aA=ax("password",{"set","reset","set a menu","set a boot","back"},aA)if aA==1 then local c8=b1("new password",true)if c8~=""then a5(8,c8)if a3(9)==""then a5(9,"menu")end end elseif aA==2 then a5(8,"")elseif aA==3 then a5(9,"menu")elseif aA==4 then a5(9,"boot")elseif aA==5 then return end end end;local function c9()while true do local bd=b1("lua")if bd==""then return end;local aI,bc=load(bd,nil,"=lua")if not aI then b0(tostring(bc or"unkown"))else local bz,bc=pcall(aI)b0(tostring(bc or"nil"))end end end;local function ca()local S=1;while true do local cb={}for j in component.list("filesystem")do local bg=component.proxy(j)if bg.exists(bW)then for Y,a2 in ipairs(bg.list(bW))do local cc=bW..a2;c(cb,{j,cc})end end end;local az={}for Y,a2 in ipairs(cb)do c(az,bh(a2[1])..":"..bR(a2[2]))end;c(az,"back")S=ax("select utility",az,S)if S>#cb then return end;local cd=cb[S]local c4=component.proxy(cd[1])local y=bO(cd[2],"/")local c3;while true do c3=ax("select mode for utility "..y,{"run","remove","clone","back"},c3)if c3==1 then local b3=b8(c4,cd[2])computer.getBootAddress=function()return cd[1]end;computer.getBootPath=function()return cd[2]end;bu(b3,"booting to utility: "..az[S].."...",false,1,true)elseif c3==2 then if aS("remove utility "..y.." from drive "..bh(c4.address).."?")then c4.remove(cd[2])break end elseif c3==3 then local ce=bn("select filesystem for clone utility "..y.." at "..bh(cd[1]),nil,nil,nil,nil,true,{c4.address})if ce then if c4.address==ce then b0("drive equals")elseif aS("clone utility "..y.." at "..bh(cd[1]).." for drive "..bh(ce).."?")then ce=component.proxy(ce)ce.makeDirectory(bW)local bz,bc=be(ce,bW..y,b8(c4,bW..y))if not bz then b0("error to write "..(bc or"unkown"))end end end else break end end end end;local function cf()local function cg()local function ch(j)if component.proxy(j).isReadOnly()then b0("this drive("..bh(j)..")is read only")return true end end;local function ci(j)if ch(j)then return end;local bd=b1("new name")if bd~=""then F("renaming...")component.proxy(j).setLabel(bd)end end;local function cj(j)if ch(j)then return end;if aS("erase label?")then F("renaming...")component.proxy(j).setLabel(nil)end end;local function ck(j)if ch(j)then return end;if aS("format? "..bh(j))then F("formatting...")component.proxy(j).remove("/")end end;local function cl(j,cm)local cn=cm and"install"or"clone"local co=j;local cp=bn(cn.." to?",nil,nil,nil,nil,true,{co})if co==cp then b0("drive equals")return end;if not cp or ch(cp)then return end;if aS(cn.." from "..bh(co).." to "..bh(cp).."?")then if cm then F("installing...")else F("cloning...")end;co=component.proxy(co)cp=component.proxy(cp)if not cm then cp.remove("/")end;local function cq(ba)local a2=""for cr in ba:gmatch("[^/\\]+")do a2=cr end;return a2 end;local function cs(ct,cu,ba,cm)for aZ,a2 in ipairs(ct.list(ba))do local cc=ba..a2;if cq(cc):sub(1,1)~="."or not cm then if ct.isDirectory(cc)then cu.makeDirectory(cc)cs(ct,cu,cc,cm)else assert(be(cu,cc,assert(b8(ct,cc))))end end end end;cs(co,cp,"/",cm)end end;local function cv(j)local cw=component.proxy(j)local cx=ad//2-3;as()at("label: "..tostring(cw.getLabel()),cx)at("address: "..tostring(b7(j)),cx+1)at("total space: "..tostring(math.floor(cw.spaceTotal()/1024)).."k",cx+2)at("total used: "..tostring(math.floor(cw.spaceUsed()/1024)).."k",cx+3)at("is read only: "..tostring(cw.isReadOnly()),cx+4)at("is bootable: "..tostring(bf(cw.address)),cx+5)aX(cx+6,true)end;local cy;while true do cy=bn("select drive",cy)if not cy then return end;aM(function()return"selected drive: "..bh(cy)end,{"rename","erase label","format","install","clone","info"},{ci,cj,ck,cl,cl,cv},{{cy},{cy},{cy},{cy,true},{cy},{cy}})end end;local bz,bc=pcall(cg)if not bz then b0(bc or"unkown")end end;local function cz()local az={}local bt={}local S=1;local X=0;for j in component.list("screen")do X=X+1;if j==a3(10)then S=X end;table.insert(bt,j)table.insert(az,b7(j))end;table.insert(az,"back")while true do S=ax("monitors",az,S)local j=bt[S]if not j then if S==#az then return end else bN(j)end end end;local function cA()local aU=aS("set sound state",true,Q)Q=aU;a5(11,aU and"1"or"0")end;local function cB()as()local bD=ad//2-9//2;local U=b7(a3(1))if not U or U==""then U="null"end;at("boot filesystem: "..U,bD)at("total memory: "..tostring(math.floor(computer.totalMemory()/1024)).."k",bD+2)at("free memory: "..tostring(math.floor(computer.freeMemory()/1024)).."k",bD+3)at("used memory: "..tostring(math.floor((computer.totalMemory()-computer.freeMemory())/1024)).."k",bD+4)local cC=0;for j,l in component.list()do cC=cC+1 end;at("components count: "..tostring(math.floor(cC)),bD+6)aX(bD+8,true)end;local function cD()aM("settings",{"resolution","password","monitor","sound"},{c5,c7,cz,cA})end;local function cE()aM("apps",{"fastboot","internet boot","bios update","lua","disk manager","web market","run utility","system info"},{bT,bU,c6,c9,cf,bX,ca,cB})end;local function cF()while a3(9)=="menu"do local bz=bL("open bios menu")if bz==nil then return end;if bz then break end end;aM("top bios v7",{"select","apps","settings","shutdown","reboot"},{bS,cE,cD,f,f},{nil,nil,nil,nil,{true}})end;G.selectfs=bn;G.menuPro=aM;G.isColor=ai;G.isControl=aV;G.menu=ax;G.getDeviceLevel=i;G.getComponent=k;G.status=F;G.splash=b0;G.split=T;G.sound=R;G.optimizeBeep=L;G.delay=J;G.setText=at;G.delay=J;G.clear=as;G.writeSplash=_;G.garbage_collect=b6;G.inputZone=b1;G.waitFoTouch=aX;G.miniStr=b7;G.fsName=bh;G.bootTo=bA;G.boot=bu;G.getFile=b8;G.saveFile=be;G.isBootFs=bf;G.setResolution=bB;G.setMonitor=bN;G.endAt=bO;G.checkInternet=bJ;G.checkPassword=bL;G.getInternetFile=bE;while a3(9)=="boot"do local bz=bL("boot")if bz==nil then f()end;if bz then break end end;if a3(4)=="true"then computer.beep(1800)b0("bios runned in dev mode")end;if not aV then F("hello")if not R(0)and aa then J(1)end end;local cG=false::cH::local cI=a3(1)if cI~=""and(not component.proxy(cI)or not bf(cI))then F("old boot drive is not found clinging...")a5(1,"",true)end;if aV then::cJ::as()a9.setForeground(aj(0xFF0000,nil,true))a9.setBackground(aj(0xFFFFFF,nil,false))local bD=ad//2-3;at("TOP BIOS V7",bD)a9.setForeground(aj(0x888888,0xAAAAAA,false))a9.setBackground(0xFFFFFF)local U=b7(a3(1))if not U or U==""then U="null"end;local cK,cL=at("alt-menu",bD+1)local cM,cN=at("enter-boot",bD+2)at("boot filesystem: "..U,bD+3)at("total memory: "..tostring(math.floor(computer.totalMemory()/1024)).."k",bD+4)at("free memory: "..tostring(math.floor(computer.freeMemory()/1024)).."k",bD+5)at("used memory: "..tostring(math.floor((computer.totalMemory()-computer.freeMemory())/1024)).."k",bD+6)if not cG then R(0)cG=true end;for Y=1,50 do local aG,aH,aw,aI,aJ=computer.pullSignal(0.1)if aG=="key_down"and aH==ab then if aI==56 then R(3)cF()goto cJ elseif aI==28 then R(3)break end elseif aG=="touch"and aH==aa and aJ==0 then if aI==bD+1 and aw>=cK and aw<=cL then R(3)cF()goto cJ elseif aI==bD+2 and aw>=cM and aw<=cN then R(3)break end end end end;if not component.proxy(a3(1))then F("search for a bootable file...",1)for j in component.list("filesystem")do if bf(j)then F("installed as a bootable: "..b7(j))a5(1,j,true)break end end end;if not component.proxy(a3(1))then F("boot file in not found",0.5)computer.pullSignal(0)goto cH end;bA(a3(1))