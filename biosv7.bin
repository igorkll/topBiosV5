local table_unpack, computer_pullSignal, table_insert, ssub, table_concat, component, error, xpcall, assert, shutdown, checkArg, pairs, type, unpack, traceback = table.unpack, computer.pullSignal, table.insert, string.sub, table.concat, component, error, xpcall, assert, computer.shutdown, checkArg, pairs, type, table.unpack, debug.traceback

-------------------------------------------------------functions

local function getDeviceLevel(address)
    return tonumber(computer.getDeviceInfo()[address].width) or false
end

local function getComponent(ctype)
    local maxlevel = 0
    local deviceaddress = nil
    local finded = false

    while true do
        finded = false
        for address, ltype in component.list(ctype) do
            if ctype == ltype then
                local level = getDeviceLevel(address)
                if not level then
                    deviceaddress = address
                elseif level > maxlevel then
                    maxlevel = level
                    deviceaddress = address
                    finded = true
                    break
                end
            end
        end
        if not finded then
            return component.proxy(deviceaddress or "")
        end
    end
end

local eeprom = getComponent("eeprom")
local eeprom_address = eeprom.address
local internet = getComponent("internet")
local componentBeep = getComponent("beep")

-------------------------------------------------------guard

local originalInvoke = component.invoke
computer.setArchitecture = nil
local eepromFakeFunctions = {makeReadonly = false, get = "", set = {nil, "storage is readonly"}, setData = {nil, "storage is readonly"}, getData = "", getChecksum = "", setLabel = {nil, "storage is readonly"}, getLabel = ""}
local function fakeInvoke(address, name, ...)
    checkArg(1, address, "string")
    checkArg(2, name, "string")
    if address == eeprom.address then
        for key, value in pairs(eepromFakeFunctions) do
            if key == name then
                local valuetype = type(value)
                if valuetype == "table" then
                    return unpack(value)
                elseif valuetype == "function" then
                    return value(...)
                else
                    return value                    
                end
            end
        end
        return originalInvoke(address, name, ...)
    else
        return originalInvoke(address, name, ...)
    end
end

local function cryptoBios() component.invoke = fakeInvoke end
local function uncryptoBios() component.invoke = originalInvoke end
cryptoBios()

-------------------------------------------------------functions

local bootState, status = false

computer.pullSignal = function(time)
    local dat = {computer_pullSignal(time)}
    if not bootState and dat[1] == "component_removed" and dat[2] == eeprom_address and dat[3] == "eeprom" then
        shutdown()
    end
    return table_unpack(dat)
end

local function delay(time)
    local inTime = computer.uptime()
    while computer.uptime() - inTime < time do
        computer.pullSignal(0)
    end
end

local function optimizeBeep(freq, del, bloked)
    if componentBeep then
        componentBeep.beep({[freq] = del})
        if bloked then delay(del) end
    else
        computer.beep(freq, del)
    end
end

local soundAllow
local function sound(num)
    if bootState or not soundAllow then return false end
    if num == 0 then
        optimizeBeep(1600, 0.05, true)
        optimizeBeep(1400, 0.05, true)
        optimizeBeep(1400, 0.05, true)
        optimizeBeep(1600, 0.05)
    elseif num == 1 then
        optimizeBeep(1000, 0.2)
    elseif num == 2 then
        optimizeBeep(1333, 0.05, true)
        optimizeBeep(1333, 0.05)
    elseif num == 3 then
        optimizeBeep(2000, 0.01)
    end
    return true
end

local function split(str, sep)
    local parts, count = {}, 1
    local i = 1
    while true do
        if i > #str then break end
        local char = ssub(str, i, #sep + (i - 1))
        if not parts[count] then parts[count] = "" end
        if char == sep then
            count = count + 1
            i = i + #sep
        else
            parts[count] = parts[count] .. ssub(str, i, i)
            i = i + 1
        end
    end
    if ssub(str, #str - (#sep - 1), #str) == sep then table_insert(parts, "") end
    return parts
end

local function writeSplash()
    status("writing to eeprom")
    sound(2)
end

local function eeprom_getData()
    return originalInvoke(eeprom_address, "getData")
end

local function eeprom_setData(data)
    originalInvoke(eeprom_address, "setData", data)
end

local function getDataPart(part)
    return split(eeprom_getData(), "\n")[part] or ""
end

local function setDataPart(part, newdata, doNotSplash)
    if getDataPart(part) == newdata then return end
    if not bootState and not doNotSplash then writeSplash() end
    if newdata:find("\n") then error("\\n char") end
    parts = split(eeprom_getData(), "\n")
    for i = part, 1, -1 do
        if not parts[i] then parts[i] = "" end
    end
    parts[part] = newdata
    eeprom_setData(table_concat(parts, "\n"))
end

soundAllow = getDataPart(11) ~= "0"

-------------------------------------------------------graphics init

local gpu = getComponent("gpu")
local screen
local keyboard
local rx, ry, depth
local function noControl() gpu = {} setmetatable(gpu, {__index = function() error("gpu and screen required") end}) end
if not gpu then 
    noControl()
else
    if not component.proxy(getDataPart(10)) then
        local screen = getComponent("screen")
        if screen then
            setDataPart(10, screen.address, true)
        end
    end
    screen = getDataPart(10)
    if component.proxy(screen) then
        gpu.bind(screen)
        rx, ry = gpu.getResolution()
        depth = gpu.getDepth()
        keyboard = originalInvoke(screen, "getKeyboards")[1]
    else
        screen = nil
        noControl()
    end
end

local gpu_address
if screen then
    gpu_address = gpu.address
end

-------------------------------------------------------functions

local function isColor()
    return depth ~= 1
end

local function optimizeColor(color, simpleColor, bf)
    if not simpleColor then simpleColor = color end
    if depth ~= 1 then
        if depth == 4 then
            return simpleColor
        else
            return color
        end
    else
        return (bf and 0xFFFFFF) or 0
    end
end

-------------------------------------------------------graphics

local function invert()
    gpu.setForeground(gpu.setBackground(gpu.getForeground()))
end

local function fill()
    gpu.fill(1, 1, rx, ry, " ")
end

local function setColor(back, fore)
    gpu.setBackground(back or 0xFFFFFF)
    gpu.setForeground(fore or 0)
end

local function clear(back, fore)
    setColor(back, fore)
    fill()
end

local function setText(text, posY)
    gpu.set(math.ceil((rx / 2) - (unicode.len(text) / 2)), posY, text)
end

local function menu(label, strs, num)
    local select = num or 1
    local posY = ((ry // 2) - (#strs // 2) - 1)
    if posY < 0 then posY = 0 end
    while true do
        clear()
        local startpos = (select // ry) * ry
        local dy = posY
        if startpos == 0 then
            if not isColor() then invert() end
            setText(label, 1 + dy)
            if not isColor() then invert() end
        else
            dy = 0
        end
        setColor(nil, optimizeColor(0x888888, 0xAAAAAA, false))
        for i = 1, #strs do
            local pos = (i + 1 + dy) - startpos
            if pos >= 1 and pos <= ry then
                if keyboard and select == i then invert() end
                setText(strs[i], pos)
                if keyboard and select == i then invert() end
            end
        end
        ::noReDraw::
        local isEvent = false
        local eventName, uuid, posX, code, button = computer.pullSignal()
        if eventName == "key_down" and uuid == keyboard then
            if code == 200 and select > 1 then
                select = select - 1
                isEvent = true
            end
            if code == 208 and select < #strs then
                select = select + 1
                isEvent = true
            end
            if code == 28 then
                sound(3)
                return select
            end
        elseif eventName == "touch" and uuid == screen and button == 0 then
            code = (code + startpos) - dy
            code = code - 1
            if code >= 1 and code <= #strs then
                local text = strs[code]
                local start, textEnd = math.ceil((rx / 2) - (unicode.len(text) / 2))
                textEnd = start + (unicode.len(text) - 1)
                if posX >= start and posX <= textEnd then
                    sound(3)
                    return code
                end
            end
        elseif eventName == "scroll" and uuid == screen then
            if button == 1 and select > 1 then
                select = select - 1
                isEvent = true
            end
            if button == -1 and select < #strs then
                select = select + 1
                isEvent = true
            end
        end
        if not isEvent then
            goto noReDraw
        else
            sound(3)
        end
    end
end

local function menuPro(label, strs, utiles, args, num)
    strs[#strs + 1] = "back" --да я знаю что так нельзя, что таблица ссылачьный тип, бла бла бла даже слышать не хочу
    local num = num or 1
    while true do
        local localLabel = label
        if type(label) == "function" then localLabel = label() end
        num = menu(localLabel, strs, num)
        if num == #strs then return end
        local arg = {}
        if args and args[num] then arg = args[num] end
        utiles[num](table.unpack(arg))
    end
end

local function yesno(label, simple, state)
    if simple then
        return menu(label, {"no", "yes"}, (state and 2) or 1) == 2
    else
        return menu(label, {"no", "no", "yes", "no"}, (state and 3) or 1) == 3
    end
end

local function isControl()
    return screen and (keyboard or (math.floor(computer.getDeviceInfo()[screen].width) ~= 1))
end

local function waitFoTouch(posY)
    gpu.set(1, posY, "press enter or touch to continue...")
    while true do
        local eventName, uuid, _, code = computer.pullSignal()
        if eventName == "key_down" and uuid == keyboard then
            if code == 28 then
                break
            end
        elseif eventName == "touch" and uuid == screen then
            break
        end
    end
    sound(3)
end

function status(str, delayTime)
    if not screen then return end
    clear()
    setText(str, ry // 2)
    if delayTime then delay(delayTime) end
end

local function splash(str)
    if not screen then return end
    if not isControl() then status(str, 1) return end
    clear()
    gpu.set(1, 1, str)
    waitFoTouch(2)
end

local function input(posX, posY, crypto)
    if not keyboard then
        splash("keyboard is not found, touch to cancel input")
        return ""
    end
    local buffer = ""
    while true do
        gpu.set(posX, posY, "_")
        local eventName, uuid, char, code = computer.pullSignal()
        if eventName == "key_down" and uuid == keyboard then
            if code == 28 then
                sound(3)
                return buffer
            elseif code == 14 then
                if unicode.len(buffer) > 0 then
                    buffer = unicode.sub(buffer, 1, unicode.len(buffer) - 1)
                    gpu.set(posX, posY, " ")
                    posX = posX - 1
                    gpu.set(posX, posY, " ")
                    sound(3)
                end
            elseif char ~= 0 then
                buffer = buffer .. unicode.char(char)
                gpu.set(posX, posY, (crypto and "*") or unicode.char(char))
                posX = posX + 1
                sound(3)
            end
        elseif eventName == "clipboard" and uuid == keyboard then
            buffer = buffer .. char
            gpu.set(posX, posY, char)
            posX = posX + unicode.len(char)
            if unicode.sub(char, unicode.len(char), unicode.len(char)) == "\n" then
                sound(3)
                return unicode.sub(buffer, 1, unicode.len(buffer) - 1)
            end
        elseif eventName == "touch" and uuid == screen then
            if #buffer == 0 then return "" end
        end
    end
end

local function inputZone(text, crypto)
    clear()
    gpu.set(1, 1, text..": ")
    return input(unicode.len(text) + 3, 1, crypto)
end

local function garbage_collect()
    status("garbage collection")
    for i = 1, 5 do computer.pullSignal(0.1) end
end

-------------------------------------------------------functions

local function miniStr(uuid)
    if not uuid then return nil end
    return uuid:sub(1, 6)
end

local function getFile(fs, path)
    local file, err = fs.open(path)
    if not file then return nil, err end
    local buffer = ""
    while true do
        local read = fs.read(file, math.huge)
        if not read then break end
        buffer = buffer .. read
    end
    fs.close(file)
    return buffer
end

local function saveFile(fs, path, data)
    local file, err = fs.open(path, "w")
    if not file then return nil, err end
    fs.write(file, data)
    fs.close(file)
    return true
end

local function isBootFs(address)
    local proxy = component.proxy(address)
    return proxy.exists("/init.lua") or proxy.exists("/OS.lua")
end

local function fsName(address)
    return table_concat({miniStr(address), component.proxy(address).getLabel()}, ":")
end

local function selectfs(label, uuid, clearAllow, bottableOnly, isClear)
    local data = {n = {}, a = {}}
    for address in component.list("filesystem") do
        if not bottableOnly or isBootFs(address) then
            data.n[#data.n + 1] = fsName(address)
            data.a[#data.a + 1] = address
        end
    end
    if clearAllow then data.n[#data.n + 1] = "clear" end
    data.n[#data.n + 1] = "back"
    local num = 1
    if not isClear then
        if type(uuid) == "number" then
            num = uuid
        elseif type(uuid) == "string" then
            for i = 1, #data.a do 
                if data.a[i] == uuid then
                    num = i
                    break
                end
            end
        end
    else
        num = #data.n - 1
    end
    local select = menu(label, data.n, num)
    local address = data.a[select]
    if not address then
        if select == #data.n then
            return nil
        elseif select == (#data.n - 1) then
            return false
        end
    end
    return address
end

--[[
local function originalResolution()
    if screen then
        rx, ry = gpu.maxResolution()
        gpu.setResolution(rx, ry)
    end
end
]]

local function boot(buffer, logo, decrypto, returnCode)
    if not returnCode then returnCode = 0 end
    if decrypto then
        uncryptoBios()
    else
        cryptoBios()
    end
    computer.getBootScreen = function() return screen end
    computer.getBootGpu = function()
        if screen then
            return gpu_address
        end
        return nil
    end
    garbage_collect()
    --originalResolution()
    status(logo)
    sound(1)
    bootState = true
    assert(xpcall(assert(load(buffer, "=boot")), traceback))
    bootState = false
    cryptoBios()
    if returnCode == 0 then
        shutdown()
    elseif returnCode == 1 then
        return
    elseif returnCode == 2 then
        shutdown(true)
    end
    error("return code is not found")
end

local function bootTo(address)
    local fs, buffer = component.proxy(address)
    if fs.exists("/init.lua") then
        computer.getBootAddress = function() return address end
        computer.setBootAddress = function(address) pcall(setDataPart, 1, address) end
        buffer = getFile(fs, "/init.lua")
    elseif fs.exists("/OS.lua") then
        eepromFakeFunctions.getData = address
        eepromFakeFunctions.setData = function(address) pcall(setDataPart, 1, address) end
        buffer = getFile(fs, "/OS.lua")
    else
        error("boot file not found")
    end

    boot(buffer, "booting to drive: " .. miniStr(address) .. "...")
end

local function setResolution()
    if screen then
        local cx = tonumber(getDataPart(2))
        local cy = tonumber(getDataPart(3))
        if cx and cy and pcall(gpu.setResolution, cx, cy) then
            rx, ry = cx, cy
        else
            rx, ry = gpu.maxResolution()
            gpu.setResolution(rx, ry)
        end
    end
end
setResolution()

local function getInternetFile(url)
    if not internet then return nil, "internet card is not found" end
    local handle, data, result, reason = internet.request(url), ""
    if handle then
        while true do
            result, reason = handle.read(mathHuge)	
            if result then
                data = data .. result
            else
                handle.close()
                
                if reason then
                    return nil, reason
                else
                    return data
                end
            end
        end
    else
        return nil, "unvalid address"
    end
end

local function checkInternet(noSplash)
    if not internet then 
        if not noSplash then splash("internet card is not found") end
        return true
    end
end

local function checkPassword(text)
    local data = getDataPart(8)
    if data == "" then return true end
    local userInput = inputZone("password" .. ((text and (" to " .. text)) or ""), true)
    if userInput == "" then return nil end
    return data == userInput
end

local function setMonitor(address)
    setDataPart(10, address)
    clear(0, 0)
    screen = address
    gpu.bind(address)
    setResolution()
    clear(0, 0)
    keyboard = originalInvoke(address, "getKeyboards")[1]
    depth = gpu.getDepth()
end

local function endAt(...)
    local buff = ""
    for i, data in ipairs(split(...)) do
        buff = data
    end
    return buff
end

local function miniUrl(url)
    return split(split(url, "//")[2], "/")[1] .. ":" .. endAt(url, "/")
    --return endAt(url:match("[^/]+"), "//") .. ":" .. endAt(url, "/")
    --return split(url:match("[^/]+"), "//") .. ":" .. endAt(url, "/")
end

local function fileName(str)
    return endAt(str, "/"):match("[^.%.]+")
end

-------------------------------------------------------init

if getDataPart(4) == "true" then
    eepromFakeFunctions = {}
end

-------------------------------------------------------application

local function selectbootdevice()
    local isClear
    while true do
        local address = selectfs("select", getDataPart(1), true, true, isClear)
        isClear = nil
        if address then
            setDataPart(1, address)
        elseif address == false then
            setDataPart(1, "")
            isClear = true
        else
            return
        end
    end
end

local function fastboot()
    local address = selectfs("fastboot", nil, nil, true)
    if address then
        bootTo(address)
    end
end

local function internetBoot(mainUrl, decrypto)
    if checkInternet() then return end
    local url = mainUrl
    if not url then
        url = inputZone("url")
        if url == "" then return end
    end
    local buffer, err = getInternetFile(url)
    if not buffer then splash(err or "unkown") return end

    computer.getBootUrl = function() return url end
    boot(buffer, "booting to url: " .. miniUrl(url) .. "...", decrypto, 1)
end

local function webMarket()
    while true do
        if checkInternet() then return end

        local buffer, err = getInternetFile("https://raw.githubusercontent.com/igorkll/webMarket/main/filelist.txt")
        if not buffer then splash(err or "unkown") return end

        local list, names, links, cryptoRuns = split(buffer, "\n"), {}, {}, {}
        for i = 1, #list do
            local dat = list[i]
            if dat then
                local link, name, cryptoRun = table_unpack(split(dat, ";"))
                if link and name then
                    names[#names + 1] = fileName(name)
                    links[#links + 1] = link
                    cryptoRuns[#cryptoRuns + 1] = cryptoRun == "true"
                end
            end
        end
        names[#names + 1] = "back"

        local select = menu("web apps", names)
        local link = links[select]
        if not link then return end

        internetBoot(link, not cryptoRuns[select])
    end
end

local function resolution()
    local strs = {"80x25", "50x16", "25x8", "64x32", "40x20", "32x16", "20x10", "clear", "back"}
    local select = 1
    while true do
        select = menu("resolution", strs, select)
        if select == 8 then
            setDataPart(2, "")
            setDataPart(3, "")
            setResolution()
        elseif select == 9 then
            return
        else
            local resolution = split(strs[select], "x")
            setDataPart(2, tostring(resolution[1]))
            setDataPart(3, tostring(resolution[2]))
            setResolution()
        end
    end
end

local function biosUpdate(noSplash)
    if checkInternet(noSplash) then return end
    status("downloading the update file")
    local file, err = getInternetFile("https://raw.githubusercontent.com/igorkll/topBiosV5/main/biosv7.bin")
    if not file then
        if not noSplash then splash(err or "unkown") end
        return
    end
    if file ~= originalInvoke(eeprom_address, "get") then
        if yesno("update?") then
            writeSplash()
            originalInvoke(eeprom_address, "set", file)
            shutdown(true)
        end
    else
        if not noSplash then splash("update not found") end
    end
end

local function password()
    while true do
        local ok = checkPassword("open password cfg")
        if ok == nil then return end
        if ok then break end
    end
    local select = 1
    while true do
        select = menu("password", {"set", "reset", "set a menu", "set a boot", "back"}, select)
        if select == 1 then
            local input = inputZone("new password", true)
            if input ~= "" then
                setDataPart(8, input)
                if getDataPart(9) == "" then setDataPart(9, "menu") end
            end
        elseif select == 2 then
            setDataPart(8, "")
        elseif select == 3 then
            setDataPart(9, "menu")
        elseif select == 4 then
            setDataPart(9, "boot")
        elseif select == 5 then
            return
        end
    end
end

local function lua()
    while true do
        clear()
        gpu.set(1, 1, "lua: ")
        local read = input(6, 1)
        if read == "" then return end
        local code, err = load(read, nil, "=lua")
        if not code then
            splash(err or "unkown")
        else
            local ok, err = pcall(code)
            splash(tostring(err or "nil"))
        end
    end
end

local function runUtility()
    local utilitiesPath = "/topBios/utilities/"

    local utilities = {}
    for address in component.list("filesystem") do
        local proxy = component.proxy(address)
        if proxy.exists(utilitiesPath) then
            for i, data in ipairs(proxy.list(utilitiesPath)) do
                local fullPath = utilitiesPath .. data
                table_insert(utilities, {address, fullPath})
            end
        end
    end

    local strs = {}
    for i, data in ipairs(utilities) do
        table_insert(strs, fsName(data[1]) .. ":" .. fileName(data[2]))
    end
    table_insert(strs, "back")

    local num = menu("select utility", strs)
    if num > #utilities then return end
    local utility = utilities[num]

    local buffer = getFile(component.proxy(utility[1]), utility[2])

    computer.getBootAddress = function() return utility[1] end
    computer.getBootPath = function() return utility[2] end
    boot(buffer, "booting to utility: " .. strs[num] .. "...", false, 1)
end

local function diskMenager()
    local function main()
        local function readonlySplash(address) 
            if component.proxy(address).isReadOnly() then
                splash("this drive(" .. fsName(address) .. ")is read only")
                return true
            end
        end

        local function renamer(address)
            if readonlySplash(address) then return end
            clear()
            gpu.set(1, 1, "new name: ")
            local read = input(11, 1)
            if read ~= "" then
                status("renaming...")
                component.proxy(address).setLabel(read)
            end
        end
        local function eraseLabel(address)
            if readonlySplash(address) then return end
            if yesno("erase label?") then
                status("renaming...")
                component.proxy(address).setLabel(nil)
            end
        end
        local function formater(address)
            if readonlySplash(address) then return end
            if yesno("format? " .. fsName(address)) then
                status("formatting...")
                component.proxy(address).remove("/")
            end
        end
        local function installer(address, install)
            local installOrClone = ((install and "install") or "clone")
            local drive1 = address
            local drive2 = selectfs(installOrClone .. " to?")
            if drive1 == drive2 then splash("drive equals") return end
            if not drive2 or readonlySplash(drive2) then return end
            if yesno(installOrClone .. " from ".. fsName(drive1) .." to ".. fsName(drive2) .."?") then
                if install then
                    status("installing...")
                else
                    status("cloning...")
                end
                drive1 = component.proxy(drive1)
                drive2 = component.proxy(drive2)
                if not install then drive2.remove("/") end
                local function fsname(path)
                    local data = ""
                    for substring in path:gmatch("[^/\\]+") do
                        data = substring
                    end
                    return data
                end
                local function copy(fs1, fs2, path, install)
                    for _, data in ipairs(fs1.list(path)) do
                        local fullPath = path..data
                        if fsname(fullPath):sub(1, 1) ~= "." or not install then
                            if fs1.isDirectory(fullPath) then
                                fs2.makeDirectory(fullPath)
                                copy(fs1, fs2, fullPath, install)
                            else
                                assert(saveFile(fs2, fullPath, assert(getFile(fs1, fullPath))))
                            end
                        end
                    end
                end
                copy(drive1, drive2, "/", install)
            end
        end
        local function informer(address)
            local drive = component.proxy(address)
            clear()
            gpu.set(1, 1, "label: " .. tostring(drive.getLabel()))
            gpu.set(1, 2, "address: " .. tostring(miniStr(address)))
            gpu.set(1, 3, "total space: " .. tostring(math.floor(drive.spaceTotal() / 1024)) .. "k")
            gpu.set(1, 4, "total used: " .. tostring(math.floor(drive.spaceUsed() / 1024)) .. "k")
            gpu.set(1, 5, "is read only: " .. tostring(drive.isReadOnly()))
            gpu.set(1, 6, "is bootable: " .. tostring(isBootFs(drive.address)))
            waitFoTouch(7)
        end

        local selected
        while true do
            selected = selectfs("select drive", selected)
            if not selected then return end

            menuPro(function() return "selected drive: " .. fsName(selected) end, {"rename", "erase label", "format", "install", "clone", "info"},
            {renamer, eraseLabel, formater, installer, installer, informer},
            {{selected}, {selected}, {selected}, {selected, true}, {selected}, {selected}})
        end
    end
    local ok, err = pcall(main)
    if not ok then splash(err or "unkown") end
end

local function monitor()
    local strs = {}
    local addresses = {}
    local num = 1
    local count = 0
    for address in component.list("screen") do
        count = count + 1
        if address == getDataPart(10) then
            num = count
        end
        table.insert(addresses, address)
        table.insert(strs, miniStr(address))
    end
    table.insert(strs, "back")

    while true do
        num = menu("monitors", strs, num)
        local address = addresses[num]
        if not address then
            if num == #strs then
                return
            end
        else
            setMonitor(address)
        end
    end
end

local function soundMenu()
    local state = yesno("set sound state", true, soundAllow)
    soundAllow = state
    setDataPart(11, (state and "1") or "0")
end

local function settingsMenu()
    menuPro("settings", {"resolution", "password", "monitor", "sound"},
    {resolution, password, monitor, soundMenu})
end

local function apps()
    menuPro("apps", {"fastboot", "internet boot", "bios update", "lua", "disk manager", "web market", "run utility"},
    {fastboot, internetBoot, biosUpdate, lua, diskMenager, webMarket, runUtility})
end

local function mainmenu()
    while getDataPart(9) == "menu" do
        local ok = checkPassword("open bios menu")
        if ok == nil then return end
        if ok then break end
    end
    menuPro("top bios v7", {"select", "apps", "settings", "shutdown", "reboot"},
    {selectbootdevice, apps, settingsMenu, shutdown, shutdown},
    {nil, nil, nil, nil, {true}})
end

-------------------------------------------------------main

garbage_collect()

while getDataPart(9) == "boot" do
    local ok = checkPassword("boot")
    if ok == nil then shutdown() end
    if ok then break end
end

if getDataPart(4) == "true" then
    computer.beep(1800)
    splash("bios runned in dev mode")
end

if not isControl() then
    status("hello")
    if not sound(0) and screen then delay(1) end
end

local isPlay = false

::respring::

local bootAddress = getDataPart(1)
if bootAddress ~= "" and (not component.proxy(bootAddress) or not isBootFs(bootAddress)) then
    setDataPart(1, "")
end

if isControl() then
    ::startMenu::
    clear()
    gpu.setForeground(optimizeColor(0xFF0000, nil, true))
    gpu.setBackground(optimizeColor(0xFFFFFF, nil, false))
    gpu.set(1, 1, "TOP BIOS V7")
    gpu.setForeground(optimizeColor(0x888888, 0xAAAAAA, false))
    gpu.setBackground(0xFFFFFF)

    local str = miniStr(getDataPart(1))
    if not str or str == "" then str = "null" end
    gpu.set(1, 2, "boot: " .. str)
    gpu.set(1, 3, "alt-menu")
    gpu.set(1, 4, "enter-boot")

    if not isPlay then
        sound(0)
        isPlay = true
    end

    for i = 1, 50 do
        local eventName, uuid, posX, code, button = computer.pullSignal(0.1)
        if eventName == "key_down" and uuid == keyboard then
            if code == 56 then
                sound(3)
                mainmenu()
                goto startMenu
            elseif code == 28 then
                sound(3)
                break
            end
        elseif eventName == "touch" and uuid == screen and button == 0 then
            if code == 3 and posX <= 8 then
                sound(3)
                mainmenu()
                goto startMenu
            elseif code == 4 and posX <= 10 then
                sound(3)
                break
            end
        end
    end
end

if not component.proxy(getDataPart(1)) then
    status("search for a bootable file", 0.3)
    for address in component.list("filesystem") do
        if isBootFs(address) then
            status("installed as a bootable: " .. miniStr(address))
            setDataPart(1, address, true)
            break
        end
    end
end

if not component.proxy(getDataPart(1)) then
    status("boot file in not found", 0.3)
    computer.pullSignal(0) --no moitor crash fix
    goto respring
end

bootTo(getDataPart(1))